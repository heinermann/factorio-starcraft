local Entity = require('__stdlib__/stdlib/entity/entity')
local Tile = require('__stdlib__/stdlib/area/tile')
local ForceTile = require('src.ForceTile')
local ForceSurface = require('src.ForceSurface')

------------------------------------------------------------------------------------------------------------------------------------------
-- LOCAL CONSTANTS
------------------------------------------------------------------------------------------------------------------------------------------
local VARIATION_IDLE = 1
local VARIATION_WORKING = 2
local VARIATION_DISABLED = 3

------------------------------------------------------------------------------------------------------------------------------------------
-- PYLON POWER LOGIC
------------------------------------------------------------------------------------------------------------------------------------------

local POWER_KEY = "powered"

local requires_power = {
    ["starcraft-robotics-facility"] = true,
    ["starcraft-observatory"] = true,
    ["starcraft-gateway"] = true,
    ["starcraft-cannon"] = true,
    ["starcraft-citadel"] = true,
    ["starcraft-cyber-core"] = true,
    ["starcraft-archives"] = true,
    ["starcraft-forge"] = true,
    ["starcraft-stargate"] = true,
    ["starcraft-fleet-beacon"] = true,
    ["starcraft-tribunal"] = true,
    ["starcraft-robotics-support-bay"] = true,
    ["starcraft-shield-battery"] = true
}

local powered_entities = {
    "starcraft-robotics-facility",
    "starcraft-observatory",
    "starcraft-gateway",
    "starcraft-cannon",
    "starcraft-citadel",
    "starcraft-cyber-core",
    "starcraft-archives",
    "starcraft-forge",
    "starcraft-stargate",
    "starcraft-fleet-beacon",
    "starcraft-tribunal",
    "starcraft-robotics-support-bay",
    "starcraft-shield-battery"
}

-- Starcraft uses a matrix exactly like this internally, which is generated from IMG_PYLON_POWER_TOP,
-- using pixel hit detection and mirrored in all direction. This one was generated by hand by tracing the
-- algorithm at twice the granularity because one Factorio tile is half of a Starcraft tile.
local bPsiFieldMask = {
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
    { 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 },
    { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0 },
    { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 },
    { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 },
    { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 },
    { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0 },
    { 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 },
    { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
}

-- width: 32 (+-16)
-- height: 20 (+-10)

local function IsCellPowered(surface, x, y, force)
    return ForceTile.get_data(surface, force, POWER_KEY, {x, y}) > 0
end

local function UpdateProtossPower(surface, force, area)
    local structures = surface.find_entities_filtered{
        area = area,
        name = powered_entities,
        force = force
    }

    for _, bldg in ipairs(structures) do
        -- TODO: Check extra associated data to determine whether the entity should be enabled again. Other mods might also disable things for various reasons.
        -- Those reasons may be unclear from our perspective but we can at least deduce whether or not it was set by us.
        if IsCellPowered(surface, bldg.position.x, bldg.position.y, force) then
            -- TODO: if it was previously disabled by us, then...
            bldg.active = true
            bldg.graphics_variation = VARIATION_IDLE
        else
            -- TODO: set data to indicate that we disabled it for being unpowered and not any other reason
            bldg.active = false
            bldg.graphics_variation = VARIATION_DISABLED
        end
    end
end

local function ModifyPsiField(surface, x, y, force, change)
    x = math.floor(x) - 16
    y = math.floor(y) - 10

    for psi_y = 1, 20 do
        for psi_x = 1, 32 do
            if bPsiFieldMask[psi_y][psi_x] == 1 then
                local power = ForceTile.get_data(surface, force, POWER_KEY, {x + psi_x, y + psi_y}) or 0

                power = power + change
                if power <= 0 then
                    power = nil
                end
                ForceTile.set_data(surface, force, POWER_KEY, {x + psi_x, y + psi_y}, power)
            end
        end
    end

    UpdateProtossPower(surface, force, {{x, y}, {x + 32, y + 20}})
end

local function AddPsiField(surface, x, y, force)
    ModifyPsiField(surface, x, y, force, 1)
end

local function RemovePsiField(surface, x, y, force)
    ModifyPsiField(surface, x, y, force, 1)
end

------------------------------------------------------------------------------------------------------------------------------------------
-- PROTOSS SHIELD LOGIC
------------------------------------------------------------------------------------------------------------------------------------------

local shield_values = {
    ["starcraft-nexus"] = 750,
    ["starcraft-robotics-facility"] = 500,
    ["starcraft-pylon"] = 300,
    ["starcraft-assimilator"] = 450,
    ["starcraft-observatory"] = 250,
    ["starcraft-gateway"] = 500,
    ["starcraft-cannon"] = 100,
    ["starcraft-citadel"] = 450,
    ["starcraft-cyber-core"] = 500,
    ["starcraft-archives"] = 500,
    ["starcraft-forge"] = 500,
    ["starcraft-stargate"] = 600,
    ["starcraft-fleet-beacon"] = 500,
    ["starcraft-tribunal"] = 500,
    ["starcraft-robotics-support-bay"] = 450,
    ["starcraft-shield-battery"] = 200
}

-- TODO

-- Factorio doesn't support the concept of shields outside of equipment grids, so we'll have to implement it ourselves.
function InitShields(entity)
    local data = Entity.get_data(entity) or {}

    if shield_values[entity.name] ~= nil then
        data.max_shields = shield_values[entity.name]
        data.shields = data.max_shields
    end

    Entity.set_data(entity, data)
end


------------------------------------------------------------------------------------------------------------------------------------------
-- PROTOSS SHIELD BATTERY LOGIC
------------------------------------------------------------------------------------------------------------------------------------------

-- TODO



------------------------------------------------------------------------------------------------------------------------------------------
-- PROTOSS ABILITIES LOGIC (CUnitPSpells.cpp)
------------------------------------------------------------------------------------------------------------------------------------------

-- TODO (prototypes are wack for now)

function CreatePsionicStorm(x, y)
end

function CreateDisruptionWeb(x, y)
end

function ApplyMaelstromGround(x, y, entity)
end

function ApplyStasisGround(x, y, entity)
end

-- Hallucination needs a new separate entity for all units, vehicles, and robots which gets its HP cut in half and deal zero damage.
-- This will be a pain in the ass to do?
function DispatchHallucinate(entity)
end

function DispatchCastMindControl(entity)
end

function DispatchCastFeedback(entity)
end

function DispatchRecall(entity)
end
