local CUnitProtoss = {}

local Entity = require('__stdlib__/stdlib/entity/entity')
local Position = require('__stdlib__/stdlib/area/position')
local math = require('__stdlib__/stdlib/utils/math')

local ForceTile = require('src.ForceTile')

------------------------------------------------------------------------------------------------------------------------------------------
-- LOCAL CONSTANTS
------------------------------------------------------------------------------------------------------------------------------------------
local VARIATION_IDLE = 1
local VARIATION_WORKING = 2
local VARIATION_DISABLED = 3

------------------------------------------------------------------------------------------------------------------------------------------
-- PYLON POWER LOGIC
------------------------------------------------------------------------------------------------------------------------------------------

local POWER_KEY = "powered"
local PYLON_ENTITY_NAME = "starcraft-pylon"

local requires_power = {
    ["starcraft-robotics-facility"] = true,
    ["starcraft-observatory"] = true,
    ["starcraft-gateway"] = true,
    ["starcraft-cannon"] = true,
    ["starcraft-citadel"] = true,
    ["starcraft-cyber-core"] = true,
    ["starcraft-archives"] = true,
    ["starcraft-forge"] = true,
    ["starcraft-stargate"] = true,
    ["starcraft-fleet-beacon"] = true,
    ["starcraft-tribunal"] = true,
    ["starcraft-robotics-support-bay"] = true,
    ["starcraft-shield-battery"] = true
}

local powered_entities = {
    "starcraft-robotics-facility",
    "starcraft-observatory",
    "starcraft-gateway",
    "starcraft-cannon",
    "starcraft-citadel",
    "starcraft-cyber-core",
    "starcraft-archives",
    "starcraft-forge",
    "starcraft-stargate",
    "starcraft-fleet-beacon",
    "starcraft-tribunal",
    "starcraft-robotics-support-bay",
    "starcraft-shield-battery"
}

-- Starcraft uses a matrix exactly like this internally, which is generated from IMG_PYLON_POWER_TOP,
-- using pixel hit detection and mirrored in all direction. This one was generated by hand by tracing the
-- algorithm at twice the granularity because one Factorio tile is half of a Starcraft tile.
local bPsiFieldMask = {
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
    { 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 },
    { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0 },
    { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 },
    { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 },
    { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 },
    { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0 },
    { 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 },
    { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
}

-- width: 32 (+-16)
-- height: 20 (+-10)

local function IsCellPowered(surface, position, force)
    return (ForceTile.get_data(surface, force, POWER_KEY, position) or 0) > 0
end

local function UpdateProtossPowerSingle(entity)
    -- TODO: Check extra associated data to determine whether the entity should be enabled again. Other mods might also disable things for various reasons.
    -- Those reasons may be unclear from our perspective but we can at least deduce whether or not it was set by us.
    if IsCellPowered(entity.surface, entity.position, entity.force) then
        -- TODO: if it was previously disabled by us, then...
        entity.active = true
        entity.graphics_variation = VARIATION_IDLE
    else
        -- TODO: set data to indicate that we disabled it for being unpowered and not any other reason
        entity.active = false
        entity.graphics_variation = VARIATION_DISABLED
    end
end

local function UpdateProtossPower(surface, force, area)
    local structures = surface.find_entities_filtered{
        area = area,
        name = powered_entities,
        force = force
    }

    for _, bldg in ipairs(structures) do
        UpdateProtossPowerSingle(bldg)
    end
end

local function ModifyPsiField(surface, position, force, change)
    local pos = Position.floor(position)

    pos.x = pos.x - 16
    pos.y = pos.y - 10

    for psi_y = 1, 20 do
        for psi_x = 1, 32 do
            if bPsiFieldMask[psi_y][psi_x] == 1 then
                local target_pos = Position.add(pos, {x = psi_x, y = psi_y})
                local power = ForceTile.get_data(surface, force, POWER_KEY, target_pos) or 0

                power = power + change
                if power <= 0 then
                    power = nil
                end
                ForceTile.set_data(surface, force, POWER_KEY, target_pos, power)
            end
        end
    end

    UpdateProtossPower(surface, force, {pos, {pos.x + 32, pos.y + 20}})
end

local function AddPsiField(surface, position, force)
    ModifyPsiField(surface, position, force, 1)
end

local function RemovePsiField(surface, position, force)
    ModifyPsiField(surface, position, force, -1)
end

------------------------------------------------------------------------------------------------------------------------------------------
-- PROTOSS SHIELD LOGIC
------------------------------------------------------------------------------------------------------------------------------------------

local shield_values = {
    ["starcraft-nexus"] = 750,
    ["starcraft-robotics-facility"] = 500,
    ["starcraft-pylon"] = 300,
    ["starcraft-assimilator"] = 450,
    ["starcraft-observatory"] = 250,
    ["starcraft-gateway"] = 500,
    ["starcraft-cannon"] = 100,
    ["starcraft-citadel"] = 450,
    ["starcraft-cyber-core"] = 500,
    ["starcraft-archives"] = 500,
    ["starcraft-forge"] = 500,
    ["starcraft-stargate"] = 600,
    ["starcraft-fleet-beacon"] = 500,
    ["starcraft-tribunal"] = 500,
    ["starcraft-robotics-support-bay"] = 450,
    ["starcraft-shield-battery"] = 200
}

-- TODO

-- Factorio doesn't support the concept of shields outside of equipment grids, so we'll have to implement it ourselves.
local function InitShields(entity)
    local data = Entity.get_data(entity) or {}

    if shield_values[entity.name] ~= nil then
        data.max_shields = shield_values[entity.name]
        data.shields = data.max_shields
    end

    Entity.set_data(entity, data)
end

function CUnitProtoss.get_shields(entity)
    local data = Entity.get_data(entity) or {}
    return data.shields or 0
end

function CUnitProtoss.max_shields(entity)
    local data = Entity.get_data(entity) or {}
    return data.max_shields or 0
end

function CUnitProtoss.add_shields(entity, amount)
    local data = Entity.get_data(entity) or {}

    if data.max_shields then
        data.shields = math.clamp(data.shields + amount, 0, data.max_shields)
        Entity.set_data(entity, data)
    end
end

function CUnitProtoss.set_shields(entity, amount)
    local data = Entity.get_data(entity) or {}

    if data.max_shields then
        data.shields = math.clamp(amount, 0, data.max_shields)
        Entity.set_data(entity, data)
    end
end

function CUnitProtoss.get_shield_ratio(entity)
    local data = Entity.get_data(entity) or {}

    if data.max_shields then
        return data.shields / data.max_shields
    end
end


------------------------------------------------------------------------------------------------------------------------------------------
-- PROTOSS SHIELD BATTERY LOGIC
------------------------------------------------------------------------------------------------------------------------------------------

-- TODO



------------------------------------------------------------------------------------------------------------------------------------------
-- PROTOSS ABILITIES LOGIC (CUnitPSpells.cpp)
------------------------------------------------------------------------------------------------------------------------------------------

-- TODO (prototypes are wack for now)

local function CreatePsionicStorm(x, y)
end

local function CreateDisruptionWeb(x, y)
end

local function ApplyMaelstromGround(x, y, entity)
end

local function ApplyStasisGround(x, y, entity)
end

-- Hallucination needs a new separate entity for all units, vehicles, and robots which gets its HP cut in half and deal zero damage.
-- This will be a pain in the ass to do?
local function DispatchHallucinate(entity)
end

local function DispatchCastMindControl(entity)
end

local function DispatchCastFeedback(entity)
end

local function DispatchRecall(entity)
end

------------------------------------------------------------------------------------------------------------------------------------------
-- Callback Logic
------------------------------------------------------------------------------------------------------------------------------------------
function CUnitProtoss.on_pylon_destroyed(entity)
    RemovePsiField(entity.surface, entity.position, entity.force)
end

function CUnitProtoss.on_pylon_created(entity)
    AddPsiField(entity.surface, entity.position, entity.force)
end

function CUnitProtoss.on_powered_bldg_created(entity)
    UpdateProtossPowerSingle(entity)
end

function CUnitProtoss.on_damaged(entity)

end



return CUnitProtoss
